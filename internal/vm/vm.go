package vm

import (
	"fmt"

	"github.com/mcvoid/dialogue/internal/program"
	"github.com/mcvoid/dialogue/internal/types/asm"
)

// The public-facing interfaces for the VM

// Function is a callback for custom events fired with the Call instruction.
type Function struct {
	// Func is the actual code which handles the events
	Func func(vm *VM, args ...asm.Value) ExecutionType
}

// ExecutionType tells the VM whether to suspend ot keep running after a callback is executed.
type ExecutionType int

const (
	// PauseExecution tells the VM to suspend
	PauseExecution ExecutionType = iota
	// ContinueExecution tells the VM to keep running
	ContinueExecution
)

// Option is a builder-like function for instantiating a new VM
type Option func(*VM) error

// New instantiates a new VM.
func New(program program.Program, options ...Option) (*VM, error) {
	ignoreAndContinue := func(vm *VM, text string) ExecutionType { return ContinueExecution }
	ignore := func(vm *VM) {}
	ignoreChoice := func(vm *VM, choices []string) {}

	vm := VM{
		code:              program.Code,
		start:             program.Start,
		runState:          stoppedState,
		pc:                0,
		stack:             []asm.Value{},
		variables:         map[asm.Value]asm.Value{},
		choices:           []choice{},
		functions:         map[asm.Value]Function{},
		prototypes:        map[asm.Value][]asm.Type{},
		handleEnterNode:   ignoreAndContinue,
		handleExitNode:    ignoreAndContinue,
		handleShowLine:    ignoreAndContinue,
		handleEndDialogue: ignore,
		handleShowChoice:  ignoreChoice,
	}

	for name, proto := range program.Funcs {
		vm.prototypes[asm.Value{Type: asm.SymbolType, Val: name}] = proto
	}

	for _, opt := range options {
		if err := opt(&vm); err != nil {
			return nil, err
		}
	}

	return &vm, nil
}

// HandleEnterNode assigns a handler for the EnterNode event. Pass as an option to NewVM.
func HandleEnterNode(handler func(*VM, string) ExecutionType) Option {
	return func(vm *VM) error {
		if handler == nil {
			return fmt.Errorf("HandleEnterNode is a null handler")
		}
		vm.handleEnterNode = handler
		return nil
	}
}

// HandleExitNode assigns a handler for the ExitNode event. Pass as an option to NewVM.
func HandleExitNode(handler func(*VM, string) ExecutionType) Option {
	return func(vm *VM) error {
		if handler == nil {
			return fmt.Errorf("HandleExitNode is a null handler")
		}
		vm.handleExitNode = handler
		return nil
	}
}

// HandleShowLine assigns a handler for the ShowLine event. Pass as an option to NewVM.
func HandleShowLine(handler func(*VM, string) ExecutionType) Option {
	return func(vm *VM) error {
		if handler == nil {
			return fmt.Errorf("HandleShowLine is a null handler")
		}
		vm.handleShowLine = handler
		return nil
	}
}

// HandleEndDialogue assigns a handler for the EndDialogue event. Pass as an option to NewVM.
func HandleEndDialogue(handler func(*VM)) Option {
	return func(vm *VM) error {
		if handler == nil {
			return fmt.Errorf("HandleEndDialogue is a null handler")
		}
		vm.handleEndDialogue = handler
		return nil
	}
}

// HandleShowChoice assigns a handler for the ShowChoice event. Pass as an option to NewVM.
func HandleShowChoice(handler func(*VM, []string)) Option {
	return func(vm *VM) error {
		if handler == nil {
			return fmt.Errorf("HandleShowChoice is a null handler")
		}
		vm.handleShowChoice = handler
		return nil
	}
}

// RegisterCallback assigns a handler for a custom event which can be fired with the Call instruction.
func RegisterCallback(function Function) Option {
	return func(vm *VM) error {
		if function.Func == nil {
			return fmt.Errorf("RegisterCallback function is null")
		}
		for name := range vm.prototypes {
			vm.functions[name] = function
		}
		return nil
	}
}

// VM is the virtual machine which runs the instructions generated by the dialogue tree.
type VM struct {
	runState          runState
	code              []asm.Instruction
	start             int
	pc                int
	stack             []asm.Value
	choices           []choice
	variables         map[asm.Value]asm.Value
	functions         map[asm.Value]Function
	prototypes        map[asm.Value][]asm.Type
	handleEnterNode   func(*VM, string) ExecutionType
	handleExitNode    func(*VM, string) ExecutionType
	handleShowLine    func(*VM, string) ExecutionType
	handleEndDialogue func(*VM)
	handleShowChoice  func(*VM, []string)
}

// Run executes the program from its start point.
// Assigned variables are persisted across runs.
func (vm *VM) Run() error {
	switch vm.runState {
	case runningState:
		fallthrough
	case suspendedState:
		fallthrough
	case waitingForInputState:
		return fmt.Errorf("cannot run a vm that is already running")
	case errorState:
		return fmt.Errorf("vm is in an error state - reset the vm to continue")
	}
	vm.runState = runningState
	vm.pc = vm.start
	vm.stack = []asm.Value{}
	vm.choices = []choice{}
	return run(vm)
}

// Resume continues the execution of a paused VM from the point it was paused.
func (vm *VM) Resume() error {
	if vm.runState != suspendedState {
		return fmt.Errorf("vm cannot resume when not in a suspended state")
	}
	vm.runState = runningState
	return run(vm)
}

// Reset stops a VM and clears its variables so that the next time it runs,
// it will be as if running for the first time.
func (vm *VM) Reset() {
	vm.runState = stoppedState
	vm.variables = map[asm.Value]asm.Value{}
}

// ChooseAndResume will notify the VM that an option was selected and resumes from the decision point
// according to the option chosen.
// Which options are available are given by the ShowChoice event, which is fired at the decision point
// and puts the VM into a waiting state until an option is chosen.
func (vm *VM) ChooseAndResume(selectedChoice int) error {
	if vm.runState != waitingForInputState {
		return fmt.Errorf("cannot set choice when vm is not waiting for input")
	}

	if selectedChoice < 0 || selectedChoice >= len(vm.choices) {
		return fmt.Errorf("choice selection out of range")
	}

	vm.runState = runningState
	vm.pc = vm.choices[selectedChoice].dest.Val.(int)
	vm.choices = []choice{}

	return run(vm)
}

// GetVariable retrieves a named variable saved by the StoreVariable
// instruction or by the SetVarableT() series of methods.
// If the variable does not exist, val is Null and exists is false.
func (vm *VM) GetVariable(name string) (val asm.Value, exists bool) {
	sym := asm.Value{Type: asm.SymbolType, Val: name}
	val, ok := vm.variables[sym]
	if !ok {
		val = asm.Null
	}
	return val, ok
}

// SetVariableNumber stores val as a number under the given name. Name strings
// are converted into symbol values.
// Saved variables are persisted across runs.
func (vm *VM) SetVariableNumber(name string, val int) {
	sym := asm.Value{Type: asm.SymbolType, Val: name}
	vm.variables[sym] = asm.Value{Type: asm.NumberType, Val: val}
}

// SetVariableBoolean stores val as a boolean under the given name. Name strings
// are converted into symbol values.
// Saved variables are persisted across runs.
func (vm *VM) SetVariableBoolean(name string, val bool) {
	sym := asm.Value{Type: asm.SymbolType, Val: name}
	vm.variables[sym] = asm.Value{Type: asm.BooleanType, Val: val}
}

// SetVariableString stores val as a string under the given name. Name strings
// are converted into symbol values.
// Saved variables are persisted across runs.
func (vm *VM) SetVariableString(name string, val string) {
	sym := asm.Value{Type: asm.SymbolType, Val: name}
	vm.variables[sym] = asm.Value{Type: asm.StringType, Val: val}
}

// SetVariableNull stores a null value under the given name. Name strings
// are converted into symbol values.
// Saved variables are persisted across runs.
func (vm *VM) SetVariableNull(name string) {
	sym := asm.Value{Type: asm.SymbolType, Val: name}
	vm.variables[sym] = asm.Null
}
